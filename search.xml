<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Gaussian Discriminant Analysis Model]]></title>
    <url>%2F05%2F04%2F2020%2F1%2F</url>
    <content type="text"><![CDATA[When we have a classification problem in which the input features $x$ are continuous-valued random variables, we canthen use the Gaussian Discriminant Analysis (GDA) model, which models $p(x|y)$ using a multivariate normal distribution.The model is: $$\begin{aligned}y&amp;\sim\text{Bernoulli}(\phi)\x|y=0&amp;\sim\mathcal{N}(\mu_0,\Sigma)\x|y=1&amp;\sim\mathcal{N}(\mu_1,\Sigma)\end{aligned}$$ Writing out the distribution, this is: $$\begin{aligned}p(y)&amp;=\phi^y(1-\phi)^{1-y}\p(x|y=0)&amp;=\frac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}}\exp\left(-\frac{1}{2}(x-\mu_0)^T\Sigma^{-1}(x-\mu_0)\right)\p(x|y=1)&amp;=\frac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}}\exp\left(-\frac{1}{2}(x-\mu_1)^T\Sigma^{-1}(x-\mu_1)\right)\end{aligned}$$ Here, the parameters of our model are $\phi$, $\Sigma$, $\mu_0$, and $\mu_1$. (Note this model is usually applied usingonly one covariance matrix $\Sigma$.) The log-likelihood of the data is given by $$\begin{aligned}\ell(\phi,\mu_0,\mu_1,\Sigma)&amp;=\log\prod_{i=1}^mp(x^{(i)},y^{(i)};\phi,\mu_0,\mu_1,\Sigma)\&amp;=\log\prod_{i=1}^mp(x^{(i)}|y^{(i)};\mu_0,\mu_1,\Sigma)p(y^{(i)};\phi).\end{aligned}$$ By maximizing $\ell$ with respect to the parameters, we find the maximum likelihood estimate of the parameters to be: $$\begin{aligned}\phi&amp;=\frac{1}{m}\sum_{i=1}^m\bold{1}{y^{(i)}=1}\\mu_0&amp;=\frac{\sum_{i=1}^m\bold{1}{y^{(i)}=0}x^{(i)}}{\sum_{i=1}^m\bold{1}{y^{(i)}=0}}\\mu_1&amp;=\frac{\sum_{i=1}^m\bold{1}{y^{(i)}=1}x^{(i)}}{\sum_{i=1}^m\bold{1}{y^{(i)}=1}}\\Sigma&amp;=\frac{1}{m}\sum_{i=1}^m(x^{(i)}-\mu_{y^{(i)}})(x^{(i)}-\mu_{y^{(i)}})^T\end{aligned}$$ Shown in the ﬁgure are the training set, as well as the contours of the two Gaussian distributions that have been fit tothe data in each of the two classes. Note that the two Gaussians have contours that are the same shape and orientation,since they share a covariance matrix $\Sigma$, but they have diﬀerent means $\mu_0$ and $\mu_1$. Also shown in the figure is thestraight line giving the decision boundary at which $p(y=1|x)=0.5$. On one side of the boundary, we’ll predict $y=1$to be the most likely outcome, and on the other side, we’ll predict $y=0$.To summarize: GDA makes stronger modeling assumptions, and is more data eﬃcient (i.e., requires less training data tolearn “well”) when the modeling assumptions are correct or at least approximately correct. Logistic regression makesweaker assumptions, and is signiﬁcantly more robust to deviations from modeling assumptions. Speciﬁcally, when the datais indeed non-Gaussian, then in the limit of large datasets, logistic regression will almost always do better than GDA. For this reason, in practice logistic regression is used more often than GDA. (Some related considerations about discriminative vs. generative models also apply for the Naive Bayes algorithm that we discuss next, but the Naive Bayes algorithm is still considered a very good, and is certainly also a very popular, classiﬁcation algorithm.)]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>GDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install the Latest Nginx on Ubuntu]]></title>
    <url>%2F05%2F04%2F2020%2F1%2F</url>
    <content type="text"><![CDATA[First, install necessary tools with the command: 1sudo apt-get install curl gnupg2 ca-certificates lsb-release There is an official NGINX repository where the latest version can be found. To add this repository, create a new .list file with the command: 1echo "deb http://nginx.org/packages/mainline/ubuntu `lsb_release -cs` nginx" | tee /etc/apt/sources.list.d/nginx.list Before installation, the NGINX public key must be added. To do this, issue the following commands: 1cd /tmp/ &amp;&amp; curl -fsSL https://nginx.org/keys/nginx_signing.key | apt-key add - Once you have the key installed, update apt with the command: 1apt-get update Now it’s time to install the latest version of NGINX. Do so with the command: 1apt-get install nginx Link your config file with the command: 1ln -s /var/www/website/config/my_nginx.conf /etc/nginx/conf.d/]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Monte Carlo Tree Search]]></title>
    <url>%2F05%2F25%2F2019%2F1%2F</url>
    <content type="text"><![CDATA[What is MCTS?Monte Carlo Tree Search (MCTS) is a method for making optimal decisions in artificial intelligence (AI) problems, typically move planning in combinatorial games. It combines the generality of random simulation with the precision of tree search. Research interest in MCTS has risen sharply due to its spectacular success with computer Go and potential application to a number of other difficult problems. Its application extends beyond games, and MCTS can theoretically be applied to any domain that can be described in terms of {state, action} pairs and simulation used to forecast outcomes. Basic AlgorithmThe basic MCTS algorithm is simple: a search tree is built, node by node, according to the outcomes of simulated playouts. The process can be broken down into the following steps. 1. SelectionStarting at root node R, recursively select optimal child nodes (explained below) until a leaf node L is reached. 2. ExpansionIf L is a not a terminal node (i.e. it does not end the game) then create one or more child nodes and select one C. 3. SimulationRun a simulated playout from C until a result is achieved. 4. BackpropagationUpdate the current move sequence with the simulation result. Each node must contain two important pieces of information: an estimated value based on simulation results and the number of times it has been visited. In its simplest and most memory efficient implementation, MCTS will add one child node per iteration. Note, however, that it may be beneficial to add more than one child node per iteration depending on the application. Node SelectionBandits and UCBNode selection during tree descent is achieved by choosing the node that maximises some quantity, analogous to the multiarmed bandit problem in which a player must choose the slot machine (bandit) that maximises the estimated reward each turn. An Upper Confidence Bounds (UCB) formula of the following form is typically used:$$ v_i+C\times\sqrt{\frac{lnN}{n_i}} $$where $v_i$ is the estimated value of the node, $n_i$ is the number of the times the node has been visited and $N$ is the total number of times that its parent has been visited. $C$ is a tunable bias parameter. Exploitation vs ExplorationThe UCB formula balances the exploitation of known rewards with the exploration of relatively unvisited nodes to encourage their exercise. Reward estimates are based on random simulations, so nodes must be visited a number of times before these estimates become reliable; MCTS estimates will typically be unreliable at the start of a search but converge to more reliable estimates given sufficient time and perfect estimates given infinite time.MCTS and UCTKocsis and Szepervari (2006) first formalised a complete MCTS algorithm by extending UCB to minimax tree search and named it the Upper Confidence Bounds for Trees (UCT) method. This is the algorithm used in the vast majority of current MCTS implementations. UCT may be described as a special case of MCTS, that is: UCT = MCTS + UCB. BenefitsMCTS offers a number of advantages over traditional tree search methods. AheuristicMCTS does not require any strategic or tactical knowledge about the given domain to make reasonable decisions. The algorithm can function effectively with no knowledge of a game apart from its legal moves and end conditions; this means that a single MCTS implementation can be reused for a number of games with little modification, and makes MCTS a potential boon for general game playing. AsymmetricMCTS performs asymmetric tree growth that adapts to the topology of the search space. The algorithm visits more interesting nodes more often, and focusses its search time in more relevant parts of the tree.This makes MCTS suitable for games with large branching factors such as 19x19 Go. Such large combinatorial spaces typically cause problems for standard depth- or breadth-based search methods, but the adaptive nature of MCTS means that it will (eventually) find those moves that appear optimal and focus its search effort there.AnytimeThe algorithm can be halted at any time to return the current best estimate. The search tree built thus far may be discarded or preserved for future reuse. DrawbacksMCTS has few drawbacks, but they can be major. Playing StrengthThe MCTS algorithm, in its basic form, can fail to find reasonable moves for even games of medium complexity within a reasonable amount of time. This is mostly due to the sheer size of the combinatorial move space and the fact that key nodes may not be visited enough times to give reliable estimates. SpeedMCTS search can take many iterations to converge to a good solution, which can be an issue for more general applications that are difficult to optimise. For example, the best Go implementations can require millions of playouts in conjunction with domain specific optimisations and enhancements to make expert moves, whereas the best GGP implementations may only make tens of (domain independent) playouts per second for more complex games. For reasonable move times, such GGPs may barely have time to visit each legal move and it is unlikely that significant search will occur. Luckily, the performance of the algorithm can be sigificantly improved using a number of techniques. ImprovementsDozens of MCTS enhancements have been suggested to date. These can generally be described as being either domain knowledge or domain independent. Domain KnowledgeDomain knowledge specific to the current game can be exploited in the tree to filter out implausible moves or in the simulations to produce heavy playouts that are more similar to playouts that would occur between human opponents. This means that playout results will be more realistic than random simulations and that nodes will require fewer iterations to yield realistic reward values. Domain knowledge can yield significant improvements, at the expense of speed and loss of generality. Domain IndependentDomain independent enhancements apply to all problem domains. These are typically applied in the tree (e.g. AMAF) although again some apply to the simulations (e.g. prefer winning moves during playouts). Domain independent enhancements do not tie the implementation to a particular domain, maintaining generality, and are hence the focus of most current work in the area.]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>MCTS</tag>
      </tags>
  </entry>
</search>
