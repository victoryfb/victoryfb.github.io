<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[object Object]]]></title>
    <url>%2F05%2F10%2F2020%2F1%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Gaussian Discriminant Analysis Model]]></title>
    <url>%2F05%2F04%2F2020%2F1%2F</url>
    <content type="text"><![CDATA[From Stanford CS229 When we have a classification problem in which the input features xxx are continuous-valued random variables, we can then use the Gaussian Discriminant Analysis (GDA) model, which models p(x&#x2223;y)p(x|y)p(x&#x2223;y) using a multivariate normal distribution. The model is: y&#x223C;Bernoulli(&#x3D5;)x&#x2223;y=0&#x223C;N(&#x3BC;0,&#x3A3;)x&#x2223;y=1&#x223C;N(&#x3BC;1,&#x3A3;) \begin{aligned} y&amp;\sim\text{Bernoulli}(\phi)\\ x|y=0&amp;\sim\mathcal{N}(\mu_0,\Sigma)\\ x|y=1&amp;\sim\mathcal{N}(\mu_1,\Sigma) \end{aligned} yx&#x2223;y=0x&#x2223;y=1&#x200B;&#x223C;Bernoulli(&#x3D5;)&#x223C;N(&#x3BC;0&#x200B;,&#x3A3;)&#x223C;N(&#x3BC;1&#x200B;,&#x3A3;)&#x200B; Writing out the distribution, this is: p(y)=&#x3D5;y(1&#x2212;&#x3D5;)1&#x2212;yp(x&#x2223;y=0)=1(2&#x3C0;)n/2&#x2223;&#x3A3;&#x2223;1/2exp&#x2061;(&#x2212;12(x&#x2212;&#x3BC;0)T&#x3A3;&#x2212;1(x&#x2212;&#x3BC;0))p(x&#x2223;y=1)=1(2&#x3C0;)n/2&#x2223;&#x3A3;&#x2223;1/2exp&#x2061;(&#x2212;12(x&#x2212;&#x3BC;1)T&#x3A3;&#x2212;1(x&#x2212;&#x3BC;1)) \begin{aligned} p(y)&amp;=\phi^y(1-\phi)^{1-y}\\ p(x|y=0)&amp;=\frac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}}\exp\left(-\frac{1}{2}(x-\mu_0)^T\Sigma^{-1}(x-\mu_0)\right)\\ p(x|y=1)&amp;=\frac{1}{(2\pi)^{n/2}|\Sigma|^{1/2}}\exp\left(-\frac{1}{2}(x-\mu_1)^T\Sigma^{-1}(x-\mu_1)\right) \end{aligned} p(y)p(x&#x2223;y=0)p(x&#x2223;y=1)&#x200B;=&#x3D5;y(1&#x2212;&#x3D5;)1&#x2212;y=(2&#x3C0;)n/2&#x2223;&#x3A3;&#x2223;1/21&#x200B;exp(&#x2212;21&#x200B;(x&#x2212;&#x3BC;0&#x200B;)T&#x3A3;&#x2212;1(x&#x2212;&#x3BC;0&#x200B;))=(2&#x3C0;)n/2&#x2223;&#x3A3;&#x2223;1/21&#x200B;exp(&#x2212;21&#x200B;(x&#x2212;&#x3BC;1&#x200B;)T&#x3A3;&#x2212;1(x&#x2212;&#x3BC;1&#x200B;))&#x200B; Here, the parameters of our model are &#x3D5;\phi&#x3D5;, &#x3A3;\Sigma&#x3A3;, &#x3BC;0\mu_0&#x3BC;0&#x200B;, and &#x3BC;1\mu_1&#x3BC;1&#x200B;. (Note this model is usually applied using only one covariance matrix &#x3A3;\Sigma&#x3A3;.) The log-likelihood of the data is given by &#x2113;(&#x3D5;,&#x3BC;0,&#x3BC;1,&#x3A3;)=log&#x2061;&#x220F;i=1mp(x(i),y(i);&#x3D5;,&#x3BC;0,&#x3BC;1,&#x3A3;)=log&#x2061;&#x220F;i=1mp(x(i)&#x2223;y(i);&#x3BC;0,&#x3BC;1,&#x3A3;)p(y(i);&#x3D5;). \begin{aligned} \ell(\phi,\mu_0,\mu_1,\Sigma) &amp;=\log\prod_{i=1}^mp(x^{(i)},y^{(i)};\phi,\mu_0,\mu_1,\Sigma)\\ &amp;=\log\prod_{i=1}^mp(x^{(i)}|y^{(i)};\mu_0,\mu_1,\Sigma)p(y^{(i)};\phi). \end{aligned} &#x2113;(&#x3D5;,&#x3BC;0&#x200B;,&#x3BC;1&#x200B;,&#x3A3;)&#x200B;=logi=1&#x220F;m&#x200B;p(x(i),y(i);&#x3D5;,&#x3BC;0&#x200B;,&#x3BC;1&#x200B;,&#x3A3;)=logi=1&#x220F;m&#x200B;p(x(i)&#x2223;y(i);&#x3BC;0&#x200B;,&#x3BC;1&#x200B;,&#x3A3;)p(y(i);&#x3D5;).&#x200B; By maximizing &#x2113;\ell&#x2113; with respect to the parameters, we find the maximum likelihood estimate of the parameters to be: &#x3D5;=1m&#x2211;i=1m1{y(i)=1}&#x3BC;0=&#x2211;i=1m1{y(i)=0}x(i)&#x2211;i=1m1{y(i)=0}&#x3BC;1=&#x2211;i=1m1{y(i)=1}x(i)&#x2211;i=1m1{y(i)=1}&#x3A3;=1m&#x2211;i=1m(x(i)&#x2212;&#x3BC;y(i))(x(i)&#x2212;&#x3BC;y(i))T \begin{aligned} \phi&amp;=\frac{1}{m}\sum_{i=1}^m\bold{1}\{y^{(i)}=1\}\\ \mu_0&amp;=\frac{\sum_{i=1}^m\bold{1}\{y^{(i)}=0\}x^{(i)}}{\sum_{i=1}^m\bold{1}\{y^{(i)}=0\}}\\ \mu_1&amp;=\frac{\sum_{i=1}^m\bold{1}\{y^{(i)}=1\}x^{(i)}}{\sum_{i=1}^m\bold{1}\{y^{(i)}=1\}}\\ \Sigma&amp;=\frac{1}{m}\sum_{i=1}^m(x^{(i)}-\mu_{y^{(i)}})(x^{(i)}-\mu_{y^{(i)}})^T \end{aligned} &#x3D5;&#x3BC;0&#x200B;&#x3BC;1&#x200B;&#x3A3;&#x200B;=m1&#x200B;i=1&#x2211;m&#x200B;1{y(i)=1}=&#x2211;i=1m&#x200B;1{y(i)=0}&#x2211;i=1m&#x200B;1{y(i)=0}x(i)&#x200B;=&#x2211;i=1m&#x200B;1{y(i)=1}&#x2211;i=1m&#x200B;1{y(i)=1}x(i)&#x200B;=m1&#x200B;i=1&#x2211;m&#x200B;(x(i)&#x2212;&#x3BC;y(i)&#x200B;)(x(i)&#x2212;&#x3BC;y(i)&#x200B;)T&#x200B; Shown in the &#xFB01;gure are the training set, as well as the contours of the two Gaussian distributions that have been fit to the data in each of the two classes. Note that the two Gaussians have contours that are the same shape and orientation, since they share a covariance matrix &#x3A3;\Sigma&#x3A3;, but they have di&#xFB00;erent means &#x3BC;0\mu_0&#x3BC;0&#x200B; and &#x3BC;1\mu_1&#x3BC;1&#x200B;. Also shown in the figure is the straight line giving the decision boundary at which p(y=1&#x2223;x)=0.5p(y=1|x)=0.5p(y=1&#x2223;x)=0.5. On one side of the boundary, we&#x2019;ll predict y=1y=1y=1 to be the most likely outcome, and on the other side, we&#x2019;ll predict y=0y=0y=0. To summarize: GDA makes stronger modeling assumptions, and is more data e&#xFB03;cient (i.e., requires less training data to learn &#x201C;well&#x201D;) when the modeling assumptions are correct or at least approximately correct. Logistic regression makes weaker assumptions, and is signi&#xFB01;cantly more robust to deviations from modeling assumptions. Speci&#xFB01;cally, when the data is indeed non-Gaussian, then in the limit of large datasets, logistic regression will almost always do better than GDA. For this reason, in practice logistic regression is used more often than GDA. (Some related considerations about discriminative vs. generative models also apply for the Naive Bayes algorithm that we discuss next, but the Naive Bayes algorithm is still considered a very good, and is certainly also a very popular, classi&#xFB01;cation algorithm.)]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>GDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install the Latest Nginx on Ubuntu]]></title>
    <url>%2F05%2F04%2F2020%2F1%2F</url>
    <content type="text"><![CDATA[First, install necessary tools with the command: 1sudo apt-get install curl gnupg2 ca-certificates lsb-release There is an official NGINX repository where the latest version can be found. To add this repository, create a new .list file with the command: 1echo &quot;deb http://nginx.org/packages/mainline/ubuntu `lsb_release -cs` nginx&quot; | tee /etc/apt/sources.list.d/nginx.list Before installation, the NGINX public key must be added. To do this, issue the following commands: 1cd /tmp/ &amp;&amp; curl -fsSL https://nginx.org/keys/nginx_signing.key | apt-key add - Once you have the key installed, update apt with the command: 1apt-get update Now it&apos;s time to install the latest version of NGINX. Do so with the command: 1apt-get install nginx Link your config file with the command: 1ln -s /var/www/website/config/my_nginx.conf /etc/nginx/conf.d/]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Monte Carlo Tree Search]]></title>
    <url>%2F05%2F25%2F2019%2F1%2F</url>
    <content type="text"><![CDATA[What is MCTS? Monte Carlo Tree Search (MCTS) is a method for making optimal decisions in artificial intelligence (AI) problems, typically move planning in combinatorial games. It combines the generality of random simulation with the precision of tree search. Research interest in MCTS has risen sharply due to its spectacular success with computer Go and potential application to a number of other difficult problems. Its application extends beyond games, and MCTS can theoretically be applied to any domain that can be described in terms of {state, action} pairs and simulation used to forecast outcomes. Basic Algorithm The basic MCTS algorithm is simple: a search tree is built, node by node, according to the outcomes of simulated playouts. The process can be broken down into the following steps. 1. Selection Starting at root node R, recursively select optimal child nodes (explained below) until a leaf node L is reached. 2. Expansion If L is a not a terminal node (i.e. it does not end the game) then create one or more child nodes and select one C. 3. Simulation Run a simulated playout from C until a result is achieved. 4. Backpropagation Update the current move sequence with the simulation result. Each node must contain two important pieces of information: an estimated value based on simulation results and the number of times it has been visited. In its simplest and most memory efficient implementation, MCTS will add one child node per iteration. Note, however, that it may be beneficial to add more than one child node per iteration depending on the application. Node Selection Bandits and UCB Node selection during tree descent is achieved by choosing the node that maximises some quantity, analogous to the multiarmed bandit problem in which a player must choose the slot machine (bandit) that maximises the estimated reward each turn. An Upper Confidence Bounds (UCB) formula of the following form is typically used: vi+C&#xD7;lnNni v_i+C\times\sqrt{\frac{lnN}{n_i}} vi&#x200B;+C&#xD7;ni&#x200B;lnN&#x200B;&#x200B; where viv_ivi&#x200B; is the estimated value of the node, nin_ini&#x200B; is the number of the times the node has been visited and NNN is the total number of times that its parent has been visited. CCC is a tunable bias parameter. Exploitation vs Exploration The UCB formula balances the exploitation of known rewards with the exploration of relatively unvisited nodes to encourage their exercise. Reward estimates are based on random simulations, so nodes must be visited a number of times before these estimates become reliable; MCTS estimates will typically be unreliable at the start of a search but converge to more reliable estimates given sufficient time and perfect estimates given infinite time. MCTS and UCT Kocsis and Szepervari (2006) first formalised a complete MCTS algorithm by extending UCB to minimax tree search and named it the Upper Confidence Bounds for Trees (UCT) method. This is the algorithm used in the vast majority of current MCTS implementations. UCT may be described as a special case of MCTS, that is: UCT = MCTS + UCB. Benefits MCTS offers a number of advantages over traditional tree search methods. Aheuristic MCTS does not require any strategic or tactical knowledge about the given domain to make reasonable decisions. The algorithm can function effectively with no knowledge of a game apart from its legal moves and end conditions; this means that a single MCTS implementation can be reused for a number of games with little modification, and makes MCTS a potential boon for general game playing. Asymmetric MCTS performs asymmetric tree growth that adapts to the topology of the search space. The algorithm visits more interesting nodes more often, and focusses its search time in more relevant parts of the tree. This makes MCTS suitable for games with large branching factors such as 19x19 Go. Such large combinatorial spaces typically cause problems for standard depth- or breadth-based search methods, but the adaptive nature of MCTS means that it will (eventually) find those moves that appear optimal and focus its search effort there. Anytime The algorithm can be halted at any time to return the current best estimate. The search tree built thus far may be discarded or preserved for future reuse. Drawbacks MCTS has few drawbacks, but they can be major. Playing Strength The MCTS algorithm, in its basic form, can fail to find reasonable moves for even games of medium complexity within a reasonable amount of time. This is mostly due to the sheer size of the combinatorial move space and the fact that key nodes may not be visited enough times to give reliable estimates. Speed MCTS search can take many iterations to converge to a good solution, which can be an issue for more general applications that are difficult to optimise. For example, the best Go implementations can require millions of playouts in conjunction with domain specific optimisations and enhancements to make expert moves, whereas the best GGP implementations may only make tens of (domain independent) playouts per second for more complex games. For reasonable move times, such GGPs may barely have time to visit each legal move and it is unlikely that significant search will occur. Luckily, the performance of the algorithm can be sigificantly improved using a number of techniques. Improvements Dozens of MCTS enhancements have been suggested to date. These can generally be described as being either domain knowledge or domain independent. Domain Knowledge Domain knowledge specific to the current game can be exploited in the tree to filter out implausible moves or in the simulations to produce heavy playouts that are more similar to playouts that would occur between human opponents. This means that playout results will be more realistic than random simulations and that nodes will require fewer iterations to yield realistic reward values. Domain knowledge can yield significant improvements, at the expense of speed and loss of generality. Domain Independent Domain independent enhancements apply to all problem domains. These are typically applied in the tree (e.g. AMAF) although again some apply to the simulations (e.g. prefer winning moves during playouts). Domain independent enhancements do not tie the implementation to a particular domain, maintaining generality, and are hence the focus of most current work in the area.]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>MCTS</tag>
      </tags>
  </entry>
</search>
